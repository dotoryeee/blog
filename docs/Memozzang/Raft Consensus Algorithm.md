# Raft Consensus Algorithm

Q: 7개의 노드가 raft 알고리즘으로 구성되어있다
네트워크 단절로 3노드 / 4노드 클러스터가 분리되면 어떻게 될까
A:Raft 알고리즘이 7개의 노드로 구성되어 있는 경우, 네트워크 단절로 인해 3개 노드와 4개 노드의 클러스터로 분리되면 다음과 같은 상황이 발생할 수 있습니다.

분리된 두 클러스터 모두 새로운 리더 선출이 이루어집니다. 이는 각 클러스터 내에서 노드들이 타임아웃 후 새로운 리더 선거 프로세스를 시작하기 때문입니다.

4개 노드 클러스터에서의 리더 선출은 성공합니다. 그 이유는 클러스터 내에 있는 노드들 중 과반수가 찬성표를 얻어 리더를 선출할 수 있기 때문입니다.

3개 노드 클러스터에서 리더 선출은 불확실합니다. 만약 클러스터 내의 노드들이 모두 동작 중이고, 과반수의 노드들이 찬성표를 주면 리더 선출이 가능합니다. 하지만 노드 중 하나가 고장이 나거나 참여하지 않으면, 과반수의 동의를 얻지 못해 리더 선출에 실패할 것입니다.

분리된 두 클러스터는 독립적으로 동작합니다. 이는 두 클러스터 간의 상태가 동기화되지 않아 데이터 불일치가 발생할 수 있다는 것을 의미합니다.

네트워크 단절 문제가 해결되면, 클러스터는 다시 통합되고, 다시 하나의 클러스터로 리더 선출 과정이 진행됩니다. 이때, 로그 항목들을 복구하고 동기화하는 과정을 거칩니다.

로그 복구 및 동기화 과정에서 일관성이 보장되어야 합니다. 분리된 클러스터에서 발생한 변경 사항들을 다시 하나의 클러스터로 병합하는 과정에서 충돌이나 데이터 유실이 없어야 합니다.

결론적으로, 네트워크 단절로 인해 클러스터가 분리되면, 리더 선출과 데이터 동기화에 문제가 발생할 수 있습니다. 네트워크 문제가 해결되면 클러스터가 통합되어 데이터 동기화 및 일관성을 회복해야 합니다.




bayer@kakao.com
그렇다면 7노드 raft cluster보다 5노드 raft cluster가 더 안정적이라고 말 할 수 있는걸까?
7노드와 5노드 Raft 클러스터 간의 안정성을 비교할 때, 고려해야 할 몇 가지 요소가 있습니다.

과반수 이상의 노드가 정상 작동해야 하는 원칙: Raft 클러스터에서는 항상 과반수 이상의 노드가 정상적으로 작동해야 안정적인 상태를 유지할 수 있습니다. 7노드 클러스터에서는 최소 4개의 노드가 정상 작동해야 하며, 5노드 클러스터에서는 최소 3개의 노드가 정상 작동해야 합니다.

노드 고장에 대한 허용성: 클러스터 크기가 클수록 더 많은 노드 고장을 허용할 수 있습니다. 7노드 클러스터의 경우, 최대 3개의 노드가 고장 나더라도 클러스터가 정상 작동할 수 있습니다. 반면, 5노드 클러스터에서는 최대 2개의 노드가 고장 나도 정상 작동할 수 있습니다.

네트워크 단절에 대한 민감도: 7노드 클러스터와 5노드 클러스터의 차이는 네트워크 단절에 대한 민감도에 크게 영향을 미치지 않습니다. 클러스터 크기에 관계없이, 네트워크 단절로 인해 과반수 이상의 노드가 정상 작동하지 못하면 안정성 문제가 발생할 수 있습니다.

리소스 사용량: 클러스터의 노드 수가 많을수록 리더와 팔로워 사이의 통신과 관련된 리소스 사용량이 증가합니다. 따라서, 7노드 클러스터는 5노드 클러스터에 비해 리소스 사용량이 더 높을 수 있습니다.

최종적으로, 7노드와 5노드 Raft 클러스터 간의 안정성 차이는 상황에 따라 다를 수 있습니다. 고장 허용성이 더 중요한 경우, 7노드 클러스터가 더 안정적일 수 있습니다. 하지만 리소스 사용량을 최소화하려는 경우, 5노드 클러스터가 더 적합할 수 있습니다. 네트워크 단절에 대한 민감도는 클러스터 크기에 크게 영향을 받지 않습니다.


Q:7노드 였다가 4노드/3노드로 분리된 raft cluster가 다시 하나의 term으로 병합될 때 데이터에 conflict가 발생할 수 있는데, 그러면 5노드가 더 안정적인것이 아닐까

A: 7노드 Raft 클러스터가 4노드와 3노드로 분리된 경우, 데이터 충돌(conflict)이 발생할 수 있습니다. 하지만 이러한 문제는 클러스터 크기와 독립적으로 Raft 알고리즘의 일관성을 유지하는 기능에 의해 해결됩니다.

5노드 Raft 클러스터도 비슷한 네트워크 분할 상황에 직면할 수 있습니다. 예를 들어, 3노드와 2노드로 분할될 경우, 3노드 클러스터에서는 리더가 선출되지만, 2노드 클러스터에서는 리더가 선출되지 않습니다. 이 경우, 데이터 일관성 문제는 7노드 클러스터와 비교하여 상대적으로 적을 수 있습니다.

그러나, 5노드 클러스터가 항상 7노드 클러스터보다 안정적이라고 말하기는 어렵습니다. 이는 노드 간의 네트워크 단절이나 노드 고장과 같은 요인이 클러스터의 안정성에 영향을 미칠 수 있기 때문입니다. 예를 들어, 5노드 클러스터에서 2개의 노드가 동시에 고장이 나면 정상 작동하지 않지만, 7노드 클러스터에서는 3개의 노드가 고장이 나도 정상 작동할 수 있습니다.

결론적으로, 5노드와 7노드 클러스터의 안정성은 상황에 따라 다를 수 있으며, 네트워크 분할에 대한 민감도와 고장 허용성 등 여러 요인을 고려해야 합니다. Raft 알고리즘은 데이터 충돌에 대한 일관성을 유지하도록 설계되어 있기 때문에, 클러스터 크기에 관계없이 이를 적절히 처리할 수 있습니다.



Q: 7노트에서 4노드/3노드로 분리되었다가 다시 7노트로 병합될 때
데이터 충돌 시 더 많은 노드들에 저장된 데이터가 우선권을 가질텐데
3노드에 저장된 데이터가 더 최신 데이터를 가지고있을 경우 해당 데이터는 유실되는건가

A: 네트워크 분할이 발생하여 7 노드 Raft 클러스터가 4노드와 3노드로 분리된 경우, 클러스터가 다시 병합될 때 Raft 알고리즘이 로그 복구와 동기화 과정을 거칩니다. 이 과정에서 데이터 충돌이 발생할 수 있지만, Raft 알고리즘은 데이터 일관성을 유지하기 위해 설계되어 있습니다.

분할된 4노드와 3노드 클러스터에서 리더가 각각 선출되면, 클라이언트 요청에 대한 처리를 계속 수행할 수 있습니다. 그러나 3노드 클러스터의 경우, 리더가 선출되더라도 과반수 이상의 노드에 동의를 받지 못해 데이터를 커밋할 수 없습니다. 이는 과반수 이상의 노드가 동의해야만 데이터가 안전하게 커밋될 수 있다는 Raft 알고리즘의 핵심 원칙 때문입니다.

따라서, 분할된 클러스터가 다시 병합될 때, 3노드 클러스터의 리더가 가진 최신 데이터는 아직 커밋되지 않은 상태입니다. 이런 경우, 병합된 7노드 클러스터에서 로그 복구와 동기화 과정이 수행되면서 3노드 클러스터의 리더가 가진 데이터를 동기화할 수 있습니다. 이 과정에서 데이터 유실은 발생하지 않습니다.

만약 3노드 클러스터에서 리더가 선출되지 않거나 커밋되지 않은 로그 항목이 없다면, 병합 과정에서 4노드 클러스터의 데이터가 우선권을 가지며, 3노드 클러스터의 데이터는 동기화되지 않습니다.

즉, Raft 알고리즘은 클러스터의 분할 및 병합 과정에서 발생하는 데이터 충돌과 동기화 문제를 처리하도록 설계되어 있으며, 데이터 유실이 발생하지 않도록 보장합니다.




Q: 그러면 7노드 클러스터중 4개의 노드가 완전히 삭제되면 어떻게 복구해야 하는걸까
A: 7노드 클러스터에서 4개의 노드가 완전히 삭제된 경우, 클러스터를 복구하려면 다음과 같은 단계를 거쳐야 합니다.

새로운 노드 추가: 먼저, 4개의 새로운 노드를 클러스터에 추가해야 합니다. 이렇게 하면 클러스터의 노드 수가 다시 7개로 되돌아갑니다.

리더 선출: 새로 추가된 노드와 기존 노드들이 함께 리더 선출 과정을 거쳐야 합니다. 이 과정에서 기존 노드 중 하나가 리더로 선출되어야 합니다.

로그 복구 및 동기화: 리더가 선출되면, 리더는 새로 추가된 노드들과 기존 노드들의 로그를 복구하고 동기화하는 과정을 거칩니다. 이 과정에서 리더는 로그 항목들을 새로운 노드들에게 전달하고, 새로운 노드들이 로그를 복구하도록 합니다.

클러스터 안정화: 로그 복구 및 동기화 과정이 완료되면, 클러스터는 다시 안정적인 상태로 돌아갑니다. 이 상태에서 클러스터는 클라이언트 요청을 처리하고 데이터를 저장할 수 있습니다.

이러한 복구 과정은 Raft 알고리즘의 내장 기능을 활용하여 수행할 수 있습니다. 그러나 복구 작업은 클러스터의 상태와 데이터의 중요성에 따라 신중하게 계획되어야 하며, 가능한 빠른 시간 내에 완료되어야 합니다. 이는 클러스터의 안정성을 유지하고 데이터 손실을 방지하기 위해 필요합니다.